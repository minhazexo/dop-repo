
// js/minimap.js
import { WorkerManager } from './worker.js';
export class Minimap{ constructor(canvas,viewportEl){ this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.viewportEl=viewportEl; this.worker=new WorkerManager('workers/mandlebrotWorker.js'); this.rendered=false; this.bounds={minX:-2.5,maxX:1.5,minY:-2.0,maxY:2.0}; this._dragging=false; this._initEvents(); }
  setPalette(p){ this.worker.setPalette(p); this.rendered=false; }
  async ensureRendered(iter=200,smooth=true,colorScale=4.0){ if(this.rendered) return; const {width,height}=this.canvas; const center=[(this.bounds.minX+this.bounds.maxX)/2,(this.bounds.minY+this.bounds.maxY)/2]; const scale=(this.bounds.maxY-this.bounds.minY); const idata=await this.worker.renderSmall(width,height,{ center,scale,iter,smooth,colorScale, mode:'mandelbrot',juliaC:[0,0], colorMode:0,paletteOffset:0, trapParam:[0.25,6.0] }); this.ctx.putImageData(idata,0,0); this.rendered=true; }
  updateViewport(view){ const {center,scale,canvasW,canvasH}=view; const aspect=canvasW/canvasH; const worldW=this.bounds.maxX-this.bounds.minX; const worldH=this.bounds.maxY-this.bounds.minY; const viewW=scale*aspect; const viewH=scale; const nx=(center[0]-viewW/2 - this.bounds.minX)/worldW; const ny=(center[1]-viewH/2 - this.bounds.minY)/worldH; const nw=viewW/worldW; const nh=viewH/worldH; const pw=this.canvas.width, ph=this.canvas.height; const x=nx*pw; const y=(1-nh-ny)*ph; const w=nw*pw; const h=nh*ph; const el=this.viewportEl; el.style.display='block'; const pad=10; el.style.left=`${pad + x + w/2}px`; el.style.top=`${pad + y + h/2}px`; el.style.width=`${w}px`; el.style.height=`${h}px`; }
  _initEvents(){ const wrap=this.canvas.parentElement; const rectCanvasToWorld=(px,py)=>{ const nx=px/this.canvas.width; const ny=1-py/this.canvas.height; const x=this.bounds.minX + nx*(this.bounds.maxX-this.bounds.minX); const y=this.bounds.minY + ny*(this.bounds.maxY-this.bounds.minY); return [x,y]; }; const getLocal=(e)=>{ const rect=this.canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-rect.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-rect.top; return {x,y}; }; const onDown=(e)=>{ e.preventDefault(); this._dragging=true; const p=getLocal(e); this._last=[p.x,p.y]; wrap.dispatchEvent(new CustomEvent('minimap-move',{detail:{world:rectCanvasToWorld(p.x,p.y)}})); }; const onMove=(e)=>{ if(!this._dragging) return; const p=getLocal(e); this._last=[p.x,p.y]; wrap.dispatchEvent(new CustomEvent('minimap-move',{detail:{world:rectCanvasToWorld(p.x,p.y)}})); }; const onUp=()=>{ this._dragging=false; }; wrap.addEventListener('mousedown',onDown); window.addEventListener('mousemove',onMove); window.addEventListener('mouseup',onUp); wrap.addEventListener('touchstart',onDown,{passive:false}); window.addEventListener('touchmove',onMove,{passive:false}); window.addEventListener('touchend',onUp); }
}
