
// js/controls.js
import { clamp, rectFromPoints } from './utils.js';
export class Controls{
  constructor(canvas,onChange,getState){ this.canvas=canvas; this.onChange=onChange; this.getState=getState; this._dragging=false; this._boxZoom=null; this._last={x:0,y:0}; this._initEvents(); }
  _initEvents(){ const c=this.canvas;
    c.addEventListener('wheel',(e)=>{ e.preventDefault(); const {left,top,width,height}=c.getBoundingClientRect(); const px=(e.clientX-left)/width; const py=(e.clientY-top)/height; const {center,scale}=this.getState(); const aspect=c.clientWidth/c.clientHeight; const worldX=center[0]+(px-0.5)*scale*aspect; const worldY=center[1]+(py-0.5)*scale; const dz=Math.exp(-e.deltaY*0.0015); const newScale=clamp(scale*(1/dz),1e-15,4); const newCenter=[ worldX-(px-0.5)*newScale*aspect, worldY-(py-0.5)*newScale ]; this.onChange({center:newCenter,scale:newScale}); },{passive:false});
    const onDown=(e)=>{ const isShift=e.shiftKey||(e.touches&&e.touches.length===2); this._boxZoom=isShift?{start:this._getXY(e),current:null}:null; this._dragging=!this._boxZoom; this._last=this._getXY(e); if(this._boxZoom) this._ensureOverlay(); };
    const onMove=(e)=>{ if(!this._dragging && !this._boxZoom) return; if(this._boxZoom){ this._boxZoom.current=this._getXY(e); this._updateOverlay(); return;} const now=this._getXY(e); const dx=now.x-this._last.x; const dy=now.y-this._last.y; this._last=now; const {center,scale}=this.getState(); const aspect=c.clientWidth/c.clientHeight; const newCenter=[ center[0]-dx/c.clientWidth*scale*aspect, center[1]-dy/c.clientHeight*scale ]; this.onChange({center:newCenter}); };
    const onUp=(e)=>{ if(this._boxZoom && this._boxZoom.current){ const r=rectFromPoints(this._boxZoom.start,this._boxZoom.current); if(r.w>6&&r.h>6){ const {center,scale}=this.getState(); const aspect=c.clientWidth/c.clientHeight; const x0=(r.x/c.clientWidth-0.5)*scale*aspect+center[0]; const y0=(r.y/c.clientHeight-0.5)*scale+center[1]; const x1=((r.x+r.w)/c.clientWidth-0.5)*scale*aspect+center[0]; const y1=((r.y+r.h)/c.clientHeight-0.5)*scale+center[1]; const newCenter=[(x0+x1)/2,(y0+y1)/2]; const newScale=Math.max((y1-y0),(x1-x0)/aspect); this.onChange({center:newCenter,scale:newScale}); } this._removeOverlay(); } this._dragging=false; this._boxZoom=null; };
    c.addEventListener('mousedown',onDown); window.addEventListener('mousemove',onMove); window.addEventListener('mouseup',onUp);
    let pinch=null; c.addEventListener('touchstart',(e)=>{ if(e.touches.length===1) onDown(e); else if(e.touches.length===2){ e.preventDefault(); pinch={ d0:this._dist(e.touches[0],e.touches[1]), centerPx:this._mid(e.touches[0],e.touches[1]) }; } },{passive:false});
    c.addEventListener('touchmove',(e)=>{ if(e.touches.length===1) onMove(e); else if(e.touches.length===2&&pinch){ e.preventDefault(); const d=this._dist(e.touches[0],e.touches[1]); const factor=d/pinch.d0; pinch.d0=d; const rect=c.getBoundingClientRect(); const px=(pinch.centerPx.x-rect.left)/rect.width; const py=(pinch.centerPx.y-rect.top)/rect.height; const {center,scale}=this.getState(); const aspect=c.clientWidth/c.clientHeight; const worldX=center[0]+(px-0.5)*scale*aspect; const worldY=center[1]+(py-0.5)*scale; const newScale=clamp(scale/factor,1e-15,4); const newCenter=[ worldX-(px-0.5)*newScale*aspect, worldY-(py-0.5)*newScale ]; this.onChange({center:newCenter,scale:newScale}); } },{passive:false});
    c.addEventListener('touchend',(e)=>{ if(e.touches.length===0){ onUp(e); pinch=null; } }); window.addEventListener('blur',()=>{ this._dragging=false; this._boxZoom=null; this._removeOverlay(); }); }
  _getXY(e){ const rect=this.canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-rect.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-rect.top; return {x,y}; }
  _dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy);} _mid(a,b){ return {x:(a.clientX+b.clientX)/2,y:(a.clientY+b.clientY)/2}; }
  _ensureOverlay(){ if(this._ov) return; const ov=this._ov=document.createElement('div'); ov.style.position='absolute'; ov.style.border='2px dashed rgba(96,165,250,0.9)'; ov.style.background='rgba(96,165,250,0.08)'; ov.style.pointerEvents='none'; ov.style.zIndex='10'; document.body.appendChild(ov); }
  _updateOverlay(){ if(!this._ov||!this._boxZoom) return; const rect=this.canvas.getBoundingClientRect(); const r=rectFromPoints( {x:this._boxZoom.start.x+rect.left, y:this._boxZoom.start.y+rect.top}, {x:this._boxZoom.current.x+rect.left, y:this._boxZoom.current.y+rect.top} ); this._ov.style.left=r.x+'px'; this._ov.style.top=r.y+'px'; this._ov.style.width=r.w+'px'; this._ov.style.height=r.h+'px'; }
  _removeOverlay(){ if(this._ov){ this._ov.remove(); this._ov=null; } }
}
